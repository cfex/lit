# Queries

go-lightning provides two functions for reading data: `Select` for multiple rows and `SelectSingle` for a single row.

## Select

Returns all matching rows as a slice of pointers:

```go
func Select[T any](ex Executor, query string, args ...any) ([]*T, error)
```

### Example

```go
// Get all users
users, err := lit.Select[User](db, "SELECT id, first_name, last_name, email FROM users")
if err != nil {
    return err
}

for _, user := range users {
    fmt.Printf("%s %s\n", user.FirstName, user.LastName)
}
```

### With Parameters

```go
// PostgreSQL
users, err := lit.Select[User](db,
    "SELECT id, first_name, last_name, email FROM users WHERE last_name = $1",
    "Doe")

// MySQL
users, err := lit.Select[User](db,
    "SELECT id, first_name, last_name, email FROM users WHERE last_name = ?",
    "Doe")
```

## SelectSingle

Returns a single row or nil if not found:

```go
func SelectSingle[T any](ex Executor, query string, args ...any) (*T, error)
```

### Example

```go
user, err := lit.SelectSingle[User](db,
    "SELECT id, first_name, last_name, email FROM users WHERE id = $1", id)
if err != nil {
    return err
}
if user == nil {
    fmt.Println("User not found")
    return nil
}
fmt.Printf("Found: %s\n", user.Email)
```

## Named Parameters

Write portable queries with `:name` placeholders instead of driver-specific `$1` or `?`. go-lightning parses them and converts to the correct syntax automatically.

### SelectNamed

```go
func SelectNamed[T any](ex Executor, query string, params map[string]any) ([]*T, error)
```

```go
// This query works on PostgreSQL, MySQL, and SQLite â€” no changes needed
users, err := lit.SelectNamed[User](db,
    "SELECT * FROM users WHERE last_name = :last_name AND email = :email",
    lit.P{"last_name": "Doe", "email": "john@example.com"})
```

### SelectSingleNamed

```go
func SelectSingleNamed[T any](ex Executor, query string, params map[string]any) (*T, error)
```

```go
user, err := lit.SelectSingleNamed[User](db,
    "SELECT * FROM users WHERE id = :id",
    lit.P{"id": 1})
if err != nil {
    return err
}
if user == nil {
    fmt.Println("User not found")
}
```

### Error on Missing Parameters

If a `:name` placeholder has no matching key in the params map, the function returns an error **without executing** the query:

```go
_, err := lit.SelectNamed[User](db,
    "SELECT * FROM users WHERE id = :id AND email = :email",
    lit.P{"id": 1})
// Error: missing parameter: email
```

### Manual Parsing

For advanced use, you can parse named queries yourself and then call any operation:

```go
// Infer driver from registered model
query, args, err := lit.ParseNamedQueryForModel[User](
    "SELECT * FROM users WHERE id = :id", lit.P{"id": 1})

// Or specify driver explicitly
query, args, err := lit.ParseNamedQuery(lit.PostgreSQL,
    "SELECT * FROM users WHERE id = :id", lit.P{"id": 1})
// query = "SELECT * FROM users WHERE id = $1", args = [1]
```

The parser correctly handles PostgreSQL `::` type casts, single-quoted string literals, and repeated parameters.

## Column Validation

go-lightning validates that all columns in your SELECT match fields in your struct. This catches errors early:

```go
// This will return an error if 'nonexistent' is not a field in User
users, err := lit.Select[User](db,
    "SELECT id, first_name, nonexistent FROM users")
// Error: invalid column that is not found in the struct: nonexistent
```

## Projections (DTOs)

You can project query results into any struct, not just your registered models. This is useful for:
- Selecting only specific columns
- JOINs that combine multiple tables
- Aggregations

### Partial Select

```go
type UserSummary struct {
    Id    int
    Email string
}

lit.RegisterModel[UserSummary](lit.PostgreSQL)

summaries, err := lit.Select[UserSummary](db,
    "SELECT id, email FROM users")
```

### JOIN Results

```go
type UserWithOrder struct {
    UserId    int
    UserEmail string
    OrderId   int
    Total     float64
}

lit.RegisterModel[UserWithOrder](lit.PostgreSQL)

results, err := lit.Select[UserWithOrder](db, `
    SELECT
        u.id as user_id,
        u.email as user_email,
        o.id as order_id,
        o.total
    FROM users u
    JOIN orders o ON o.user_id = u.id
    WHERE o.total > $1`, 100.00)
```

See [Projections & DTOs](/guides/projections) for more examples.

## Native Queries

For complex scenarios where automatic mapping doesn't work, use `SelectMultipleNative`:

```go
func SelectMultipleNative[T any](
    ex Executor,
    mapLine func(*interface{ Scan(...any) error }, *T) error,
    query string,
    args ...any,
) ([]*T, error)
```

This gives you full control over the scanning process:

```go
type CustomResult struct {
    Name  string
    Count int
}

results, err := lit.SelectMultipleNative[CustomResult](db,
    func(scanner *interface{ Scan(...any) error }, r *CustomResult) error {
        return (*scanner).Scan(&r.Name, &r.Count)
    },
    "SELECT name, COUNT(*) FROM items GROUP BY name")
```
